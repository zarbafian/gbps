use std::io::Read;
use std::io::Write;

use slog::debug;
use slog::o;
use slog::warn;
use slog::Logger;

/// Configuration for sending protocol monitoring data
#[derive(Clone)]
pub struct MonitoringConfig {
    /// Enable sending data
    enabled: bool,
    /// Monitoring host
    host: String,
    /// URL context
    context: String,
    /// Logger
    logger: Logger,
}

impl MonitoringConfig {
    /// Creates a new monitoring configuration
    ///
    /// # Arguments
    ///
    /// * `enabled` - Share monitoring data
    /// * `url` - URL of monitoring host
    pub fn new(enabled: bool, url: &str, logger: Logger) -> MonitoringConfig {
        // remove leading protocol
        let protocol_removed = if url.starts_with("http://") {
            &url[7..] }
        else {
            url
        };
        // separate host and context
        let (host, context) = match protocol_removed.find("/") {
            Some(index) => (&protocol_removed[..index], &protocol_removed[index..]),
            None => (url, "/")
        };
        MonitoringConfig {
            enabled,
            host: host.to_owned(),
            context: context.to_owned(),
            logger,
        }
    }

    pub fn enabled(&self) -> bool {
        self.enabled
    }

    /// Send monitoring data
    ///
    /// # Arguments
    ///
    /// * `pid` - Identifier of sending process
    /// * `peers` - List of peers in the view of the process
    pub fn send_data(&self, pid: &str, peers: Vec<String>) {
        let pid = pid.to_owned();
        let host = self.host.clone();
        let context = self.context.clone();
        let logger = self.logger.clone();
        std::thread::spawn(move || {
            let peers_str = peers.iter()
                .map(|peer| format!("\"{}\"", peer))
                .collect::<Vec<String>>().join(",");
            let json = format!(
                "{{\
                \"id\":\"{}\",\
                \"peers\":[{}],\
                \"messages\":[{}]\
            }}", pid, peers_str, "");
            //println!("send_data:\n{}", json);
            match MonitoringConfig::post(&host, &context, json, logger.clone()) {
                Ok(()) => debug!(logger, "Peer {}: monitoring data sent", pid),
                Err(e) => warn!(logger, "Peer {} could not send monitoring data to {}: {}", pid, host, e),
            }
        });
    }

    fn post(host: &str, context: &str, json: String, logger: Logger) -> std::io::Result<()> {

        let bytes = json.as_bytes();

        let mut stream = std::net::TcpStream::connect(host)?;

        let mut request_data = String::new();
        request_data.push_str(&format!("POST {} HTTP/1.1", context));
        request_data.push_str("\r\n");
        request_data.push_str(&format!("Host: {}", host));
        request_data.push_str("\r\n");
        request_data.push_str("Accept: */*");
        request_data.push_str("\r\n");
        request_data.push_str("Content-Type: application/json; charset=UTF-8");
        request_data.push_str("\r\n");
        request_data.push_str(&format!("Content-Length: {}", bytes.len()));
        request_data.push_str("\r\n");
        request_data.push_str("Connection: close");
        request_data.push_str("\r\n");
        request_data.push_str("\r\n");
        request_data.push_str(&json);

        //println!("request_data = {:?}", request_data);

        let _request = stream.write_all(request_data.as_bytes())?;
        //println!("request = {:?}", request);

        let mut buf = String::new();
        let _result = stream.read_to_string(&mut buf)?;
        //println!("result = {}", result);
        debug!(logger, "buf = {}", buf);

        Ok(())
    }
}

impl Default for MonitoringConfig {
    fn default() -> Self {
        MonitoringConfig {
            enabled: false,
            host: "".to_string(),
            context: "".to_string(),
            logger: Logger::root(slog::Discard, o!()),
        }
    }
}
